{"version":3,"file":"vue-currency-filter.min.js","sources":["../src/utils.js","../src/accounting.js","../src/VueCurrencyFilter.js"],"sourcesContent":["const nativeMap = Array.prototype.map,\n  nativeIsArray = Array.isArray,\n  toString = Object.prototype.toString\n\nexport default {\n  __isNull(obj) {\n    return typeof obj === 'undefined' || obj === null\n  },\n  __isString(obj) {\n    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr))\n  },\n  __isArray(obj) {\n    return nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]'\n  },\n  __isObject(obj) {\n    return obj && toString.call(obj) === '[object Object]'\n  },\n  __defaults(object, defs) {\n    var key\n    object = object || {}\n    defs = defs || {}\n    // Iterate over object non-prototype properties:\n    for (key in defs) {\n      if (defs.hasOwnProperty(key)) {\n        // Replace values with defaults only if undefined (allow empty/zero values):\n        if (object[key] == null) object[key] = defs[key]\n      }\n    }\n    return object\n  },\n  __map(obj, iterator, context) {\n    var results = [],\n      i, j\n\n    if (!obj) return results\n\n    // Use native .map method if it exists:\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context)\n\n    // Fallback for native .map:\n    for (i = 0, j = obj.length; i < j; i++) {\n      results[i] = iterator.call(context, obj[i], i, obj)\n    }\n    return results\n  }\n}","import utils from './utils'\n\n/*\n * accounting.js v0.4.2, Copyright 2014 Open Exchange Rates, Docs: http://openexchangerates.github.io/accounting.js/\n * --0-- Moderate and maintain by Irfan Maulana <github.com/mazipan> for Vue-Currency-Filter needed --0--\n */\n// Create the local library object, to be exported or referenced globally later\nvar lib = {}\n/* --- Exposed settings --- */\n\n// The library's settings configuration object. Contains default parameters for\n// currency and number formatting\nlib.settings = {\n  currency: {\n    symbol: '$', // default currency symbol is '$'\n    format: '%s%v', // controls output: %s = symbol, %v = value (can be object, see docs)\n    decimal: '.', // decimal point separator\n    thousand: ',', // thousands separator\n    precision: 2, // decimal places\n    grouping: 3 // digit grouping (not implemented yet)\n  },\n  number: {\n    precision: 0, // default precision on numbers is 0\n    grouping: 3, // digit grouping (not implemented yet)\n    thousand: ',',\n    decimal: '.'\n  }\n}\n\n/**\n * Check and normalise the value of precision (must be positive integer)\n */\nfunction checkPrecision(val, base) {\n  val = Math.round(Math.abs(val))\n  return isNaN(val) ? base : val\n}\n\n/**\n * Parses a format string or object and returns format obj for use in rendering\n *\n * `format` is either a string with the default (positive) format, or object\n * containing `pos` (required), `neg` and `zero` values (or a function returning\n * either a string or object)\n *\n * Either string or format.pos must contain \"%v\" (value) to be valid\n */\nfunction checkCurrencyFormat(format) {\n  var defaults = lib.settings.currency.format\n\n  // Allow function as format parameter (should return string or object):\n  if (typeof format === 'function') format = format()\n\n  // Format can be a string, in which case `value` (\"%v\") must be present:\n  if (utils.__isString(format) && format.match('%v')) {\n\n    // Create and return positive, negative and zero formats:\n    return {\n      pos: format,\n      neg: format.replace('-', '').replace('%v', '-%v'),\n      zero: format\n    }\n\n    // If no format, or object is missing valid positive value, use defaults:\n  } else if (!format || !format.pos || !format.pos.match('%v')) {\n\n    // If defaults is a string, casts it to an object for faster checking next time:\n    return (!utils.__isString(defaults)) ? defaults : lib.settings.currency.format = {\n      pos: defaults,\n      neg: defaults.replace('%v', '-%v'),\n      zero: defaults\n    }\n\n  }\n  // Otherwise, assume format was fine:\n  return format\n}\n\n/* --- API Methods --- */\n\n/**\n * Takes a string/array of strings, removes all formatting/cruft and returns the raw float value\n * Alias: `accounting.parse(string)`\n *\n * Decimal must be included in the regular expression to match floats (defaults to\n * accounting.settings.number.decimal), so if the number uses a non-standard decimal \n * separator, provide it as the second argument.\n *\n * Also matches bracketed negatives (eg. \"$ (1.99)\" => -1.99)\n *\n * Doesn't throw any errors (`NaN`s become 0) but this may change in future\n */\nvar unformat = lib.unformat = lib.parse = function (value, decimal) {\n  // Recursively unformat arrays:\n  if (utils.__isArray(value)) {\n    return utils.__map(value, function (val) {\n      return unformat(val, decimal)\n    })\n  }\n\n  // Fails silently (need decent errors):\n  value = value || 0\n\n  // Return the value as-is if it's already a number:\n  if (typeof value === 'number') return value\n\n  // Default decimal point comes from settings, but could be set to eg. \",\" in opts:\n  decimal = decimal || lib.settings.number.decimal\n\n  // Build regex to strip out everything except digits, decimal point and minus sign:\n  var regex = new RegExp('[^0-9-' + decimal + ']', ['g']),\n    unformatted = parseFloat(\n      ('' + value)\n        .replace(/\\((?=\\d+)(.*)\\)/, '-$1') // replace bracketed values with negatives\n        .replace(regex, '') // strip out any cruft\n        .replace(decimal, '.') // make sure decimal point is standard\n    )\n\n  // This will fail silently which may cause trouble, let's wait and see:\n  return !isNaN(unformatted) ? unformatted : 0\n}\n\n/**\n * Implementation of toFixed() that treats floats more like decimals\n *\n * Fixes binary rounding issues (eg. (0.615).toFixed(2) === \"0.61\") that present\n * problems for accounting- and finance-related software.\n */\nvar toFixed = lib.toFixed = function (value, precision) {\n  precision = checkPrecision(precision, lib.settings.number.precision)\n\n  var exponentialForm = Number(lib.unformat(value) + 'e' + precision)\n  var rounded = Math.round(exponentialForm)\n  var finalResult = Number(rounded + 'e-' + precision).toFixed(precision)\n  return finalResult\n}\n\n/**\n * Format a number, with comma-separated thousands and custom precision/decimal places\n * Alias: `accounting.format()`\n *\n * Localise by overriding the precision and thousand / decimal separators\n * 2nd parameter `precision` can be an object matching `settings.number`\n */\nvar formatNumber = lib.formatNumber = lib.format = function (number, precision, thousand, decimal) {\n  // Resursively format arrays:\n  if (utils.__isArray(number)) {\n    return utils.__map(number, function (val) {\n      return formatNumber(val, precision, thousand, decimal)\n    })\n  }\n\n  // Clean up number:\n  number = unformat(number)\n\n  // Build options object from second param (if object) or all params, extending defaults:\n  var opts = utils.__defaults(\n      (utils.__isObject(precision) ? precision : {\n        precision: precision,\n        thousand: thousand,\n        decimal: decimal\n      }),\n      lib.settings.number\n    ),\n    // Clean up precision\n    usePrecision = checkPrecision(opts.precision),\n\n    // Do some calc:\n    negative = number < 0 ? '-' : '',\n    base = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + '',\n    mod = base.length > 3 ? base.length % 3 : 0\n\n  // Format the number:\n  return negative + (mod ? base.substr(0, mod) + opts.thousand : '') + base.substr(mod).replace(/(\\d{3})(?=\\d)/g, '$1' + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1] : '')\n}\n\n/**\n * Format a number into currency\n *\n * Usage: accounting.formatMoney(number, symbol, precision, thousandsSep, decimalSep, format)\n * defaults: (0, \"$\", 2, \",\", \".\", \"%s%v\")\n *\n * Localise by overriding the symbol, precision, thousand / decimal separators and format\n * Second param can be an object matching `settings.currency` which is the easiest way.\n *\n * To do: tidy up the parameters\n */\nvar formatMoney = lib.formatMoney = function (number, symbol, precision, thousand, decimal, format) {\n  // Resursively format arrays:\n  if (utils.__isArray(number)) {\n    return utils.__map(number, function (val) {\n      return formatMoney(val, symbol, precision, thousand, decimal, format)\n    })\n  }\n\n  // Clean up number:\n  number = unformat(number)\n\n  // Build options object from second param (if object) or all params, extending defaults:\n  var opts = utils.__defaults(\n      (utils.__isObject(symbol) ? symbol : {\n        symbol: symbol,\n        precision: precision,\n        thousand: thousand,\n        decimal: decimal,\n        format: format\n      }),\n      lib.settings.currency\n    ),\n\n    // Check format (returns object with pos, neg and zero):\n    formats = checkCurrencyFormat(opts.format),\n\n    // Choose which format to use for this value:\n    useFormat = number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero\n\n  // Return with currency symbol added:\n  return useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(number), checkPrecision(opts.precision), opts.thousand, opts.decimal))\n}\n\n\n/**\n * Format a list of numbers into an accounting column, padding with whitespace\n * to line up currency symbols, thousand separators and decimals places\n *\n * List should be an array of numbers\n * Second parameter can be an object containing keys that match the params\n *\n * Returns array of accouting-formatted number strings of same length\n *\n * NB: `white-space:pre` CSS rule is required on the list container to prevent\n * browsers from collapsing the whitespace in the output strings.\n */\n\n// DECIDE TO REMOVE THIS METHODS -- UNUSED FOR NOW - by Irfan Maulana\n\n// lib.formatColumn = function (list, symbol, precision, thousand, decimal, format) {\n// \tif (!list || !utils.__isArray(list)) return [];\n\n// \t// Build options object from second param (if object) or all params, extending defaults:\n// \tvar opts = utils.__defaults(\n// \t\t\t(utils.__isObject(symbol) ? symbol : {\n// \t\t\t\tsymbol: symbol,\n// \t\t\t\tprecision: precision,\n// \t\t\t\tthousand: thousand,\n// \t\t\t\tdecimal: decimal,\n// \t\t\t\tformat: format\n// \t\t\t}),\n// \t\t\tlib.settings.currency\n// \t\t),\n\n// \t\t// Check format (returns object with pos, neg and zero), only need pos for now:\n// \t\tformats = checkCurrencyFormat(opts.format),\n\n// \t\t// Whether to pad at start of string or after currency symbol:\n// \t\tpadAfterSymbol = formats.pos.indexOf(\"%s\") < formats.pos.indexOf(\"%v\") ? true : false,\n\n// \t\t// Store value for the length of the longest string in the column:\n// \t\tmaxLength = 0,\n\n// \t\t// Format the list according to options, store the length of the longest string:\n// \t\tformatted = utils.__map(list, function (val, i) {\n// \t\t\tif (utils.__isArray(val)) {\n// \t\t\t\t// Recursively format columns if list is a multi-dimensional array:\n// \t\t\t\treturn lib.formatColumn(val, opts);\n// \t\t\t} else {\n// \t\t\t\t// Clean up the value\n// \t\t\t\tval = unformat(val);\n\n// \t\t\t\t// Choose which format to use for this value (pos, neg or zero):\n// \t\t\t\tvar useFormat = val > 0 ? formats.pos : val < 0 ? formats.neg : formats.zero,\n\n// \t\t\t\t\t// Format this value, push into formatted list and save the length:\n// \t\t\t\t\tfVal = useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(val), checkPrecision(opts.precision), opts.thousand, opts.decimal));\n\n// \t\t\t\tif (fVal.length > maxLength) maxLength = fVal.length;\n// \t\t\t\treturn fVal;\n// \t\t\t}\n// \t\t});\n\n// \t// Pad each number in the list and send back the column of numbers:\n// \treturn utils.__map(formatted, function (val, i) {\n// \t\t// Only if this is a string (not a nested array, which would have already been padded):\n// \t\tif (utils.__isString(val) && val.length < maxLength) {\n// \t\t\t// Depending on symbol position, pad after symbol or at index 0:\n// \t\t\treturn padAfterSymbol ? val.replace(opts.symbol, opts.symbol + (new Array(maxLength - val.length + 1).join(\" \"))) : (new Array(maxLength - val.length + 1).join(\" \")) + val;\n// \t\t}\n// \t\treturn val;\n// \t});\n// };\n\nexport default lib","import accounting from './accounting' \nimport utils from './utils'\n\nconst VueCurrencyFilter = {\n  install(Vue, options) {\n\n    const defaultConfig = {\n      symbol: '',\n      thousandsSeparator: '.',\n      fractionCount: 0,\n      fractionSeparator: ',',\n      symbolPosition: 'front',\n      symbolSpacing: true,\n      precision: 0,               // Support fixed-point currency: 0 for float, 2 for 1000Â¢ -> $10.00\n    }\n\n    if (utils.__isNull(options)) options = {}\n    let configs = utils.__defaults(options, defaultConfig)\n\n    const filterCurrency = function (value,\n      _symbol,\n      _thousandsSeparator,\n      _fractionCount,\n      _fractionSeparator,\n      _symbolPosition,\n      _symbolSpacing,\n      _precision) {\n\n      let runtimeConfig = utils.__defaults({\n        symbol: _symbol,\n        thousandsSeparator: _thousandsSeparator,\n        fractionCount: _fractionCount,\n        fractionSeparator: _fractionSeparator,\n        symbolPosition: _symbolPosition,\n        symbolSpacing: _symbolSpacing,\n        precision: _precision\n      }, configs)\n\n      if (typeof _symbol === 'object') {\n        runtimeConfig = utils.__defaults(_symbol, configs)\n      }\n\n      let result = 0.0\n      const isNegative = String(value).charAt(0) === '-'\n\n      if (isNegative) {\n        value = String(value).slice(1)\n      }\n\n      const amount = parseFloat(value)\n      if (!isNaN(amount)) {\n        result = amount\n      }\n\n      let formatConfig = '%s%v'\n      if (runtimeConfig.symbolPosition === 'front') {\n        formatConfig = runtimeConfig.symbolSpacing ? '%s %v' : '%s%v'\n      } else {\n        formatConfig = runtimeConfig.symbolSpacing ? '%v %s' : '%v%s'\n      }\n\n      if (runtimeConfig.precision > 0) {\n        value = accounting.unformat(value) / Math.pow(10, runtimeConfig.precision) // 1095 -> 10.95\n      }\n\n      if (runtimeConfig.fractionCount > 0) {\n        value = accounting.toFixed(value, runtimeConfig.fractionCount)\n      }\n\n      result = accounting.formatMoney(value, {\n        format: formatConfig,\n        symbol: runtimeConfig.symbol,\n        precision: runtimeConfig.fractionCount,\n        thousand: runtimeConfig.thousandsSeparator,\n        decimal: runtimeConfig.fractionSeparator,\n      })\n\n      if (isNegative) {\n        result = '-' + result\n      }\n\n      return result\n    }\n\n    Vue.filter('currency', filterCurrency)\n    Vue.prototype.$CurrencyFilter = {\n      setConfig: (options) => {\n        configs = utils.__defaults(options, defaultConfig)\n      },\n      getConfig: () => {\n        return configs\n      }\n    }\n  }\n}\n\nexport default VueCurrencyFilter"],"names":["nativeMap","Array","prototype","map","nativeIsArray","isArray","toString","Object","__isNull","obj","__isString","charCodeAt","substr","__isArray","call","__isObject","__defaults","object","defs","key","hasOwnProperty","__map","iterator","context","i","j","results","length","lib","checkPrecision","val","base","Math","round","abs","isNaN","settings","currency","symbol","format","decimal","thousand","precision","grouping","number","unformat","parse","value","utils","regex","RegExp","unformatted","parseFloat","replace","toFixed","exponentialForm","Number","rounded","formatNumber","opts","usePrecision","negative","parseInt","mod","split","formatMoney","formats","defaults","match","pos","neg","zero","checkCurrencyFormat","install","Vue","options","defaultConfig","thousandsSeparator","fractionCount","fractionSeparator","symbolPosition","symbolSpacing","configs","filter","_symbol","_thousandsSeparator","_fractionCount","_fractionSeparator","_symbolPosition","_symbolSpacing","_precision","runtimeConfig","_typeof","result","isNegative","String","charAt","slice","amount","formatConfig","accounting","pow","$CurrencyFilter","setConfig","getConfig"],"mappings":"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"}